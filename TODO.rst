Phoenix TODO List
=================

This is just a place for me to jot down things as I think of them.
The items are in no particular order, and the fact that something is
on this list does not mean that it will ever actually be done.
Additionally, no meaning should be attached to items being removed
from this file, it could mean that items have been done or just that
I've decided that they will not be done or no longer apply.



WAF Tool
--------

 * Update WAF
 * Add support for using the cygwin and mingw32 compilers?



Stubs for Optional Classes
--------------------------

In Classic we tend to use empty stubs for classes and etc. that are optional
and not available in a particular build of wxWidgets.  That allows the
compilations to succeed without needing to completely eliminate those wrapper
classes, and when a user tries to use one of those classes they would get a
NotImplementedError.

The big downside of that approach was that the stubs had to be maintained by
hand, which is time consuming and error prone.  However for Phoenix we have
all the info about the API so we should be able to almost completely automate
the generation of the empty stub code for those classes.  ("Almost" because
we'll need to specify which classes to do it for, and what #define flag to
check if the the feature is available in wxWidgets or if the stubs should be
compiled.)



Sphinx tweaks
-------------

The big changes are done, but here are some dangling strings that still need
to be untangled:

  * The ``chopDescription()`` function is not very smart. See if it can be made a
    little smarter and pull out the first sentence from the docstring instead
    of just the first line.

  * Convert the main.html page to a ReST file? It would probably make it a
    little easier to maintain.

  * Set max width of body sections?  I think it looks a little nicer that way,
    but we'll need to fix the floating and alignment of the sidebar to do
    it...

  * If a method is renamed it is still in the sorted list of methods at the
    position that the original name would have sorted to.  Change things to
    sort on the pyName.

  * The sphinxtools are too aggressive at ignoring content beyond a #. If the
    hash happens to be inside a string then syntax related errors can happen.
    For example:

        def SetColors(self, pen='black', fill='#A0A0A0', fill2='#E0E0E0'):
            ...




Other Assorted Stuff
--------------------

  * Locate and/or add items for the various functions and things in Classic's
    _functions.i module.

  * Add ETG scripts for these items in Classic's core:

      * msgout
      * quantize
      * dialup  ??
      * docmdi  ??
      * docview ??
      * persist ??

  * Add a _msw module that will contain classes and such that are only
    available in the Windows port:

      * [done] axbase
      * [done] metafile
      * [] wxCHMHelpController
      * [] access
      * [] New activex classes in wx/msw/ole/activex.h ?
      * Any others?

  * Add the UTF8 PyMethods from classic (see _stc_utf8_methods.py) to StyledTextCtrl

  * Reimplement the classes in the valgen, valnum and valtext headers as
    Python code, and make them visible in the core wx namespace?

  * Should demo/Main.py ignore anything in the version strings after the '-'
    when comparing?

  * Potential reference count issue with wxGridCellCoordsArray?  Code
    like this::

        theGrid.GetSelectedCells()[0][0]

    evaluates to garbage values, but this works fine::

        a = theGrid.GetSelectedCells()
        a[0]
        a[0][0]

  * In a Py3 build strings like wx.TreeCtrlNameStr are being generated as
    bytes objects, they should probably be string objects. Or not, sip's
    default might be best... See ModuleDef.addGlobalStr if I change my mind.

  * Check gui_scripts entry points.

  * wx.Window.DoEraseBackground?

  * Add tests and/or demo for DnD in DataViewCtrl. Since the DnD is done
    internally and the DataViewEvent is used for passing the data objects
    around we may need to do something to help convert the raw data to python
    DataObjects.

  * Add meaningful __hash__ methods for wx.Colour, wx.Point, etc.?

  * Double-check wx.PyEvent and wx.PyCommandEvent, does the __getattr__,
    etc. work with properties?  See:
    https://groups.google.com/d/msg/wxpython-dev/dMrpaKs_d0U/nVMY7lMvAwAJ

  * In test_lib_agw_persist_persistencemanager.py change the tests to be
    self-contained instead of some relying on files generated by others. This
    won't work if we want to run tests in parallel.

  * Port these modules from gizmos in wxCode to a pure-python wx.lib implementation?
      * DynamicSashWindow
      * LEDNumberCtrl
      * SplitTree ??
      * TreeListCtrl ??  (We have a treelist ctrl in dataview now)

  * The Masked controls modules and demos need some help with Py3 compatibility.

  * Migrate from six to python-future? It seems more comprehensive and would
    require less conditionals in the code, since you mostly just write
    py3-compatible code and py2 compatibility is handled in python-future.

  * Add type hinting to the .pyi stub files, as well as @overload decorators
    to document the C++ overloaded methods. See https://www.python.org/dev/peps/pep-0484/

  * Add doc files for the image handler classes, so we can add wrappers for them.

  * Investigate SIP's Mixin annotation for use with wx.ComboPopup class, will
    it allow it to be combined with a widget class, giving an is-a
    relationship instead of having to use has-a? Docs say that virtual methods
    can't be present with the Mixin annotation, so it may not work...

  * Consider adding immutable versions of 'value' types like wx.Point,
    wx.Size, wx.Colour, etc. so they can be used as keys in a dictionary or
    added to sets, and still retain some of their component meanings like x, y
    or width, height. Perhaps it could bo done with namedtuples with methods
    added on in a subclass to make it simple to convert back and forth...

    Or... idea #2: simply add a method to wx.Point and the others like
    ``Immutable()`` or ``MakeImmutable()`` or something similar which returns
    an appropriate namedtuple, and then update the convertFromType SIP code to
    also accept objects of that namedtuple type for automatic conversion to
    the C++ type. (Although since they are derived from tuple it probably will
    not need to be changed, but we should probably add some type-checking
    there to be safe.)

